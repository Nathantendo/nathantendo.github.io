<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>MP4 → WAV (client-side, no external scripts)</title>
<style>
body{font-family:sans-serif;max-width:800px;margin:40px auto;padding:0 20px}
button{padding:8px 14px;margin-left:8px}
#log{white-space:pre-wrap;background:#f4f4f4;border:1px solid #ccc;padding:8px;font-size:13px;margin-top:10px}
audio{margin-top:10px;width:100%}
</style>
</head>
<body>
<h1>MP4 → WAV Converter (offline JS only)</h1>
<p>Select a video (.mp4) and convert its audio to WAV right in your browser.</p>
<input type="file" id="file" accept="video/*,audio/*">
<button id="convert">Convert</button>
<div id="log"></div>
<div id="result"></div>

<script>
const fileInput = document.getElementById('file');
const logEl = document.getElementById('log');
const resultEl = document.getElementById('result');

function log(msg){ logEl.textContent += msg + "\n"; }

document.getElementById('convert').onclick = async () => {
  logEl.textContent = ''; resultEl.innerHTML = '';
  const file = fileInput.files[0];
  if(!file){ alert('Choose a file first.'); return; }
  log(`Loading ${file.name} (${(file.size/1024/1024).toFixed(1)} MB)...`);

  const url = URL.createObjectURL(file);
  const video = document.createElement('video');
  video.src = url;
  video.muted = true;
  video.crossOrigin = "anonymous";
  video.controls = false;
  video.style.display = 'none';
  document.body.appendChild(video);

  await video.play().catch(()=>{});
  await new Promise(r => setTimeout(r, 300)); // give it time to start

  const stream = video.captureStream ? video.captureStream() : video.mozCaptureStream();
  if(!stream){ alert('captureStream not supported'); return; }

  const audioStream = new MediaStream(stream.getAudioTracks());
  const recorder = new MediaRecorder(audioStream, { mimeType: 'audio/webm' });
  const chunks = [];
  recorder.ondataavailable = e => chunks.push(e.data);
  recorder.start();

  log('Recording audio in real time...');
  video.onended = () => recorder.stop();

  recorder.onstop = async () => {
    log('Finished recording, processing...');
    const webmBlob = new Blob(chunks, { type: 'audio/webm' });
    const arrayBuffer = await webmBlob.arrayBuffer();

    // Decode to raw samples
    const ctx = new (window.AudioContext || window.webkitAudioContext)();
    const audioBuffer = await ctx.decodeAudioData(arrayBuffer.slice(0));

    const wavBlob = audioBufferToWavBlob(audioBuffer);
    const wavUrl = URL.createObjectURL(wavBlob);
    log(`WAV ready (${(wavBlob.size/1024).toFixed(0)} KB)`);

    const a = document.createElement('a');
    a.href = wavUrl;
    a.download = file.name.replace(/\.[^/.]+$/, '') + '.wav';
    a.textContent = 'Download ' + a.download;
    const audio = document.createElement('audio');
    audio.controls = true;
    audio.src = wavUrl;

    resultEl.appendChild(a);
    resultEl.appendChild(audio);
    URL.revokeObjectURL(url);
    video.remove();
  };
};

// helper to make WAV
function audioBufferToWavBlob(buffer){
  const numChannels = buffer.numberOfChannels;
  const sampleRate = buffer.sampleRate;
  const bitDepth = 16;
  const blockAlign = numChannels * bitDepth/8;
  const dataSize = buffer.length * blockAlign;
  const bufferLen = 44 + dataSize;
  const arrayBuffer = new ArrayBuffer(bufferLen);
  const view = new DataView(arrayBuffer);
  writeString(view, 0, 'RIFF');
  view.setUint32(4, 36 + dataSize, true);
  writeString(view, 8, 'WAVE');
  writeString(view, 12, 'fmt ');
  view.setUint32(16, 16, true);
  view.setUint16(20, 1, true);
  view.setUint16(22, numChannels, true);
  view.setUint32(24, sampleRate, true);
  view.setUint32(28, sampleRate * blockAlign, true);
  view.setUint16(32, blockAlign, true);
  view.setUint16(34, bitDepth, true);
  writeString(view, 36, 'data');
  view.setUint32(40, dataSize, true);

  const channels = [];
  for(let i=0;i<numChannels;i++) channels.push(buffer.getChannelData(i));
  let offset = 44;
  for(let i=0;i<buffer.length;i++){
    for(let ch=0; ch<numChannels; ch++){
      let s = channels[ch][i];
      s = Math.max(-1, Math.min(1, s));
      view.setInt16(offset, s<0 ? s*0x8000 : s*0x7FFF, true);
      offset+=2;
    }
  }
  return new Blob([arrayBuffer], {type:'audio/wav'});
}
function writeString(view, offset, str){ for(let i=0;i<str.length;i++) view.setUint8(offset+i, str.charCodeAt(i)); }
</script>
</body>
</html>
